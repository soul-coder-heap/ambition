
> 4层模型: 应用层->传输层->网络层->数据链路层

> TCP 头部格式

|  |  |
| --- | --- |
| 源端口号(16) | 目标端口号(16) |
| 序列号(32)||
| 确认应答号(32)||
|首部长度(4)｜保留(6)｜U｜ACK｜P｜RST｜SYN｜FIN|窗口大小(16)
|校验和(16)|紧急指针(16)|
|选项||
|data||


> UDP 头部格式

|  |  |
| --- | --- |
| 源端口(16) | 目标端口号(16) |
| 包长度(16) | 校验和(16) |
|data||

序列号：建立连接时由计算机随机生成的的一个初始值，通过SYN包传送接收端主机，每发送一次数据，就【累加】一次该【数据字节数】的大小。`用来解决网络包乱序问题`

确认应答号：下一次【期待】的收到的数据序号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都被正常接受。`用来解决不丢包的问题`

控制位：

* ACK: 该位为 1 时，【确认应答】的字段变为有效，TCP 规定除了最初链接时的SYN包之外的该位必须设置为1.
* RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开链接。 
* SYC：该位为 1 时，表示希望连接、并在其【序列号】的字段进行序列号初始值的设定。

* FIN：该位为 1 时，表示今后不会数据发送，希望断开链接。当通信结束希望断开连接时，通信双方的主机之间交换 FIN 位置为 1 的TCP 段。


TCP 是面向连接的、可靠的、基于字节流的传输层通信协议，TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

* 面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；

* 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；

* 字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃

> 什么是TCP连接？

客户端与服务端达成共识：Socket（ip+port）、序列号（解决乱序问题）、窗口大小（流量控制）

> 唯一确定一个TCP连接？

TCP 四元组唯一确定一个连接，包括：
* ip+port(C) <--> ip+port(S)

最大TCP连接数，`2 ** 32 * 2 ** 16`, 实际受到文件描述符、内存限制的影响。

UDP / TCP 区别：TCP 20字节、UDP 8字节。

1. 连接：TCP需要，UDP不需要
2. 服务对象：TCP一对一、点对点；UDP支持一对多，多对多交互通信
3. 可靠性：TCP可靠交付、无差错、不丢包、不重复、按需到达。UDP 最大努力交付
4. 拥塞控制、流量控制
    
    - TCP 有拥塞控制和流量控制，调整传输效率
    - UDP 没有，网络堵塞拥堵、也不影响 UDP 发送效率。

5. 报文

    - TCP 首部没有选项时20字节，使用【选项】会变长。
    - UDP 首部8个字节，固定不变。

>  为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段？
    
```python

    - TCP数据长度 = IP总长度 - IP 首部长度 - TCP 首部长度（无选项是20）

    其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度

    - UDP数据长度 = IP总长度 - IP 首部长度 - UDP首部长度（8）

```

> TCP 连接过程（三次握手以及状态变迁）

[image](./img/tcp_connect.png)


    1. 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态

    2. 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
    
    3. 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态

    4.客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。

    5. 服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

    6. 第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。一旦完成三次握手，双方都处于 ESTABLISHED 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了.


> 为什么是三次？而不是2/4

    - 避免历史连接

        客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

        1. 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；    
        2. 此时服务端就会回一个 SYN + ACK 报文给客户端；
        3. 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。

    如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

    - 同步双方序列号

        TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

        1. 接收方可以去除重复的数据；
        2. 接收方可以根据数据包的序列号按序接收；
        3. 可以标识发送出去的数据包中， 哪些是已经被对方收到的；

    可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。


「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

> 为什么客户端和服务端的初始序列号 ISN 是不相同的？

因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。

> 初始序列号 ISN 是如何随机产生的？

起始 ISN 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。


> IP 网络层会分片（MTU），为什么还要在TCP层要MSS？


`报头/起始帧分解符号 + MAC头部 + IP 头部 + TCP 头部 + 数据 + FCS`

```
MTU = MAC + IP + data

MSS = data
```


[image](./img/tcp_content.png)

    * MTU : 一个网络包最大长度、以太网 1500 字节
    * MSS ：除去 IP TCP头部后，一个网络包容纳的 TCP 数据的最大长度

为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了


>  SYN 攻击， 伪造ip使得服务端，大量处于 syn_recv 状态

    - SYN_RCVD 最大个数
    - SYN 队列，ACCEPT 队列

> TCP  四次挥手断开

    1. 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。
    2. 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。
    3. 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。
    4. 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
    5. 服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。
    6. 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。

* 每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态

> 为什么需要 Time_WAIT？

1. TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
2. TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭

> time_wait 过多的危害（一般是服务器主动断开）？
1. 占用资源
2. 对端口资源的消耗（轻微）


> TCP 保活机制

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序

Linux内核中会维护两个队列：

未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；
已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；



> 关于TCP "粘包"问题的思考

1. "粘包"描述的不准确，TCP 本身是流、二进制串，本身来讲没有边际。在应用需要提供协议解决这个问题。实质是如何切分一个 TCP 包内 data段的问题，需要在程序员提供一定的手段去处理，属于应用层问题。

2. 这种问题出现的原因一般有两种，一种是发生在发送端，因为启用尼格尔算法，回对小字节的数据进行融合，组成一个TCP 包发送； 一种是在接受端recv时候错误读取时一不小心拿多了。

常见处理的方法：

    * 加入特殊标志
    * 加入长度

字符串不需要序列化和反序列化，实际中需要传输复杂的类型，定制Message消息以及协议，比如 flatbuffer， 在序列化和反序列的过程中相当于一境处理了数据的"粘包"问题。 所以成熟的网络通信需要应用层协议。
